<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ ¡åœ’æ•¸ä½æ°´æ—ç®±</title>
    <style>
        /* --- åŸºç¤è¨­å®š --- */
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #222; font-family: "Microsoft JhengHei", sans-serif; }
        
        /* æ°´æ—ç®±å®¹å™¨ */
        #aquarium {
            width: 100%; height: 100%;
            position: relative;
            overflow: hidden;
            background: linear-gradient(180deg,#4facfe 0%, #00f2fe 100%);
            background-size: cover;
            background-position: center;
            transition: background 0.5s ease;
        }

        /* èƒŒæ™¯åœ–ç‰‡å±¤ */
        #bg-image-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: contain; /* ç¢ºä¿åœ–ç‰‡å®Œæ•´é¡¯ç¤ºä¸è£åˆ‡ */
            background-color: rgba(0,0,0,0.3);
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 0;
            pointer-events: none;
        }

        /* æ²™åœ° */
        #sand {
            position: absolute; bottom: 0; width: 100%; height: 80px;
            background: #e6d99c; border-top: 5px solid #d4c585; 
            z-index: 2; 
            pointer-events: none;
            transition: opacity 0.5s;
        }

        /* --- æ“ä½œé¢æ¿ --- */
        #controls {
            position: absolute; top: 15px; left: 15px; z-index: 100;
            display: flex; flex-direction: column; gap: 10px;
        }

        .panel {
            background: rgba(255,255,255,0.95); 
            padding: 12px; 
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; gap: 8px;
            width: 200px;
        }

        h3 { margin: 0 0 5px 0; font-size: 16px; color: #333; border-bottom: 2px solid #ddd; padding-bottom: 5px; }
        
        .btn {
            border: none; padding: 10px; border-radius: 8px; 
            font-size: 14px; cursor: pointer; color: white;
            transition: transform 0.1s, opacity 0.2s;
            text-align: center; font-weight: bold;
        }
        .btn:active { transform: scale(0.96); }
        .btn-blue { background: #007bff; }
        .btn-orange { background: #fd7e14; }
        .btn-green { background: #28a745; }
        .btn-red { background: #dc3545; }
        .btn-gray { background: #6c757d; }
        
        input[type="file"] { display: none; }

        .fish { 
            position: absolute; 
            z-index: 10; 
            pointer-events: auto; 
            cursor: pointer;
            filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.3));
        }

        /* --- è£å‰ªè¦–çª— (Modal) --- */
        #modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 200;
            display: none; flex-direction: column;
        }

        #toolbar {
            height: 70px; background: #333; display: flex; align-items: center; justify-content: center; gap: 10px;
            padding: 0 10px; color: white;
        }

        #canvas-wrapper {
            flex: 1; display: flex; align-items: center; justify-content: center;
            overflow: hidden; position: relative; touch-action: none;
        }
        
        canvas { border: 2px solid #666; box-shadow: 0 0 20px rgba(0,0,0,0.5); }

        .radio-group { display: flex; gap: 10px; background: #555; padding: 5px 15px; border-radius: 20px; }
        .radio-group label { cursor: pointer; display: flex; align-items: center; gap: 5px; font-size: 14px; color: white;}

        /* --- å¤§å°é è¦½è¦–çª— (New) --- */
        #sizePreviewModal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.85); z-index: 210; 
            flex-direction: column; align-items: center; justify-content: center;
        }
        .preview-box {
            background: rgba(255,255,255,0.95); padding: 20px; border-radius: 12px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.5); text-align: center; 
            width: 300px; display: flex; flex-direction: column; align-items: center; gap: 15px;
        }
        #previewContainer {
            width: 100%; height: 200px; border: 2px dashed #ccc; 
            background: #eee; position: relative; overflow: hidden;
            display: flex; align-items: center; justify-content: center;
        }
    </style>
</head>
<body>

    <div id="aquarium">
        <img id="bg-image-layer" src="" alt="Background">
        <div id="sand"></div>

        <div id="controls">
            <div class="panel">
                <h3>ğŸŸ æ”¾å…¥åœ–ç‰‡</h3>
                <button class="btn btn-blue" onclick="document.getElementById('fishInput').click()">ğŸ“¸ ä¸Šå‚³ä¸¦è£å‰ªç•«ä½œ</button>
                <input type="file" id="fishInput" accept="image/*" onchange="handleFishFile(this)">
                <div style="font-size:12px; color:#666; text-align:center;">æ”¯æ´æ–¹å½¢æˆ–æé‚Šè£å‰ª</div>
            </div>

            <div class="panel">
                <h3>ğŸ« æ›´æ›å ´æ™¯</h3>
                <button class="btn btn-orange" onclick="document.getElementById('bgInput').click()">ğŸ–¼ï¸ ä¸Šå‚³æ ¡åœ’ç…§ç‰‡</button>
                <input type="file" id="bgInput" accept="image/*" onchange="handleBgFile(this)">
                <button class="btn btn-gray" onclick="resetBackground()">ğŸŒŠ æ¢å¾©æ·±æµ·æ¨¡å¼</button>
            </div>
        </div>
    </div>

    <div id="modal">
        <div id="toolbar">
            <div class="radio-group">
                <label><input type="radio" name="mode" value="rect" checked onclick="setMode('rect')"> ğŸŸ¦ æ–¹å½¢</label>
                <label><input type="radio" name="mode" value="poly" onclick="setMode('poly')"> âœ‚ï¸ æé‚Š</label>
            </div>
            <button class="btn btn-green" onclick="finishCrop()">ä¸‹ä¸€æ­¥</button>
            <button class="btn btn-red" onclick="resetCrop()">é‡ç½®</button>
            <button class="btn btn-gray" onclick="closeModal()">å–æ¶ˆ</button>
        </div>
        <div id="canvas-wrapper">
            <canvas id="editor"></canvas>
        </div>
        <div style="text-align:center; color:#aaa; padding:8px; font-size:14px;" id="instruction">
            æ‹–æ›³æ»‘é¼ /æ‰‹æŒ‡ç•«å‡ºæ–¹æ¡†
        </div>
    </div>

    <div id="sizePreviewModal">
        <div class="preview-box">
            <h3>ğŸ“ èª¿æ•´å¤§å°</h3>
            <div id="previewContainer">
                <img id="fishPreviewImage" src="" />
            </div>
            <div style="width: 100%;">
                <label style="font-size: 14px; color: #333;">å¯¬åº¦: <span id="currentFishSize">100</span>px</label>
                <input type="range" id="fishSizeSlider" min="30" max="250" value="100" style="width: 100%; margin-top: 5px;">
            </div>
            <div style="display: flex; gap: 10px; width: 100%; justify-content: center;">
                <button class="btn btn-green" onclick="confirmFishSize()" style="flex:1;">âœ… ç¢ºèª</button>
                <button class="btn btn-gray" onclick="cancelFishSize()" style="flex:1;">âŒ å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <script>
        // --- å…¨åŸŸè®Šæ•¸ ---
        let canvas = document.getElementById('editor');
        let ctx = canvas.getContext('2d');
        let rawImg = new Image();
        let mode = 'rect'; 
        
        let isDragging = false;
        let startPos = {x:0, y:0};
        let rectData = {x:0, y:0, w:0, h:0};
        let polyPoints = [];

        // ä¿å­˜è£å‰ªå¾Œçš„åœ–ç‰‡è³‡æ–™
        let croppedFishDataURL = '';

        // ==========================================
        //  èƒŒæ™¯æ›´æ›é‚è¼¯
        // ==========================================
        function handleBgFile(input) {
            if (input.files && input.files[0]) {
                let reader = new FileReader();
                reader.onload = function(e) {
                    const bgLayer = document.getElementById('bg-image-layer');
                    bgLayer.src = e.target.result;
                    bgLayer.style.opacity = 1; 
                    // æœ‰èƒŒæ™¯åœ–æ™‚ï¼Œéš±è—æ²™åœ°
                    document.getElementById('sand').style.display = 'none';
                }
                reader.readAsDataURL(input.files[0]);
            }
            input.value = '';
        }

        function resetBackground() {
            const bgLayer = document.getElementById('bg-image-layer');
            bgLayer.style.opacity = 0; 
            // æ¢å¾©æ·±æµ·æ™‚ï¼Œé¡¯ç¤ºæ²™åœ°
            document.getElementById('sand').style.display = 'block';
        }

        // ==========================================
        //  åœ–ç‰‡è£å‰ªé‚è¼¯
        // ==========================================
        function handleFishFile(input) {
            if (input.files && input.files[0]) {
                let reader = new FileReader();
                reader.onload = function(e) {
                    rawImg.onload = function() { openModal(); }
                    rawImg.src = e.target.result;
                }
                reader.readAsDataURL(input.files[0]);
            }
            input.value = '';
        }

        function openModal() {
            document.getElementById('modal').style.display = 'flex';
            resetCrop();
            resizeCanvas();
        }

        function closeModal() {
            document.getElementById('modal').style.display = 'none';
        }

        function resizeCanvas() {
            let wrapper = document.getElementById('canvas-wrapper');
            let maxWidth = wrapper.clientWidth - 20;
            let maxHeight = wrapper.clientHeight - 20;
            let scale = Math.min(maxWidth / rawImg.width, maxHeight / rawImg.height);
            canvas.width = rawImg.width * scale;
            canvas.height = rawImg.height * scale;
            draw();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(rawImg, 0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (mode === 'rect' && rectData.w !== 0) {
                ctx.clearRect(rectData.x, rectData.y, rectData.w, rectData.h);
                ctx.drawImage(rawImg, 
                    rectData.x / (canvas.width/rawImg.width), rectData.y / (canvas.height/rawImg.height), 
                    rectData.w / (canvas.width/rawImg.width), rectData.h / (canvas.height/rawImg.height), 
                    rectData.x, rectData.y, rectData.w, rectData.h
                );
                ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2;
                ctx.strokeRect(rectData.x, rectData.y, rectData.w, rectData.h);
            } 
            else if (mode === 'poly' && polyPoints.length > 0) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(polyPoints[0].x, polyPoints[0].y);
                for(let i=1; i<polyPoints.length; i++) ctx.lineTo(polyPoints[i].x, polyPoints[i].y);
                if(polyPoints.length > 2) ctx.closePath();
                ctx.clip();
                ctx.clearRect(0,0,canvas.width,canvas.height);
                ctx.drawImage(rawImg, 0, 0, canvas.width, canvas.height);
                ctx.restore();

                ctx.beginPath();
                ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 2;
                ctx.moveTo(polyPoints[0].x, polyPoints[0].y);
                for(let i=1; i<polyPoints.length; i++) ctx.lineTo(polyPoints[i].x, polyPoints[i].y);
                if(polyPoints.length > 2) ctx.lineTo(polyPoints[0].x, polyPoints[0].y);
                ctx.stroke();
                
                ctx.fillStyle = 'red';
                polyPoints.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill(); });
            }
        }

        // --- äº’å‹•åµæ¸¬ ---
        function getPos(e) {
            let rect = canvas.getBoundingClientRect();
            let clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        function startInteraction(e) {
            if(e.type === 'touchstart') e.preventDefault();
            let pos = getPos(e);
            if (mode === 'rect') {
                isDragging = true; startPos = pos; rectData = {x: pos.x, y: pos.y, w: 0, h: 0};
            } else {
                polyPoints.push(pos); draw();
            }
        }

        function moveInteraction(e) {
            if (!isDragging || mode !== 'rect') return;
            if(e.type === 'touchmove') e.preventDefault();
            let pos = getPos(e);
            rectData.w = pos.x - startPos.x;
            rectData.h = pos.y - startPos.y;
            draw();
        }

        function endInteraction(e) { isDragging = false; }

        canvas.addEventListener('mousedown', startInteraction);
        canvas.addEventListener('mousemove', moveInteraction);
        canvas.addEventListener('mouseup', endInteraction);
        canvas.addEventListener('touchstart', startInteraction, {passive: false});
        canvas.addEventListener('touchmove', moveInteraction, {passive: false});
        canvas.addEventListener('touchend', endInteraction);

        function setMode(newMode) {
            mode = newMode; resetCrop();
            document.getElementById('instruction').innerText = mode === 'rect' ? "æ‹–æ›³ç•«å‡ºæ–¹æ¡†" : "æ²¿è‘—é­šé‚Šç·£é»æ“Š";
        }
        function resetCrop() { rectData = {x:0, y:0, w:0, h:0}; polyPoints = []; draw(); }

        function finishCrop() {
            let tempCanvas = document.createElement('canvas');
            let tCtx = tempCanvas.getContext('2d');
            let scaleRatio = rawImg.width / canvas.width;

            if (mode === 'rect') {
                if (rectData.w === 0) return alert("è«‹å…ˆæ¡†é¸ç¯„åœ");
                let finalX = rectData.w > 0 ? rectData.x : rectData.x + rectData.w;
                let finalY = rectData.h > 0 ? rectData.y : rectData.y + rectData.h;
                let finalW = Math.abs(rectData.w);
                let finalH = Math.abs(rectData.h);
                tempCanvas.width = finalW * scaleRatio;
                tempCanvas.height = finalH * scaleRatio;
                tCtx.drawImage(rawImg, finalX * scaleRatio, finalY * scaleRatio, finalW * scaleRatio, finalH * scaleRatio, 0, 0, tempCanvas.width, tempCanvas.height);
            } else {
                if (polyPoints.length < 3) return alert("è«‹è‡³å°‘é» 3 å€‹é»");
                let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
                polyPoints.forEach(p => { if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; });
                let w = maxX - minX; let h = maxY - minY;
                tempCanvas.width = w * scaleRatio; tempCanvas.height = h * scaleRatio;
                tCtx.beginPath();
                tCtx.moveTo((polyPoints[0].x - minX) * scaleRatio, (polyPoints[0].y - minY) * scaleRatio);
                for(let i=1; i<polyPoints.length; i++) tCtx.lineTo((polyPoints[i].x - minX) * scaleRatio, (polyPoints[i].y - minY) * scaleRatio);
                tCtx.closePath(); tCtx.clip();
                tCtx.drawImage(rawImg, -minX * scaleRatio, -minY * scaleRatio, rawImg.width, rawImg.height);
            }
            
            // è£å‰ªå®Œæˆï¼Œé€²å…¥é è¦½è¦–çª—
            croppedFishDataURL = tempCanvas.toDataURL(); 
            openSizePreviewModal(croppedFishDataURL);
            closeModal();
        }

        // ==========================================
        //  å¤§å°é è¦½èˆ‡èª¿æ•´é‚è¼¯
        // ==========================================
        const sizePreviewModal = document.getElementById('sizePreviewModal');
        const fishPreviewImage = document.getElementById('fishPreviewImage');
        const fishSizeSlider = document.getElementById('fishSizeSlider');
        const currentFishSizeSpan = document.getElementById('currentFishSize');
        let finalFishSize = 100;

        function openSizePreviewModal(imgSrc) {
            fishPreviewImage.src = imgSrc;
            fishSizeSlider.value = 100; // é‡ç½®é è¨­å¤§å°
            updateFishPreview();
            sizePreviewModal.style.display = 'flex';
        }

        function updateFishPreview() {
            finalFishSize = parseInt(fishSizeSlider.value);
            currentFishSizeSpan.innerText = finalFishSize;
            
            // ç›´æ¥èª¿æ•´é è¦½åœ–ç‰‡çš„å¯¬åº¦
            fishPreviewImage.style.width = finalFishSize + 'px';
            // é«˜åº¦è‡ªå‹•ï¼Œä¿æŒæ¯”ä¾‹
            fishPreviewImage.style.height = 'auto'; 
        }

        fishSizeSlider.addEventListener('input', updateFishPreview);

        function confirmFishSize() {
            if (croppedFishDataURL) {
                createFish(croppedFishDataURL, finalFishSize); 
                croppedFishDataURL = ''; 
            }
            sizePreviewModal.style.display = 'none';
        }

        function cancelFishSize() {
            croppedFishDataURL = '';
            sizePreviewModal.style.display = 'none';
        }

        // ==========================================
        //  æ°´æ—ç®±å‹•ç•«
        // ==========================================
        const aquarium = document.getElementById('aquarium');
        const fishes = [];

        class Fish {
            constructor(imgSrc, customSize) {
                this.element = document.createElement('img');
                this.element.src = imgSrc;
                this.element.className = 'fish';
                
                // ä½¿ç”¨è‡ªå®šç¾©å¤§å°
                this.size = customSize; 
                this.element.style.width = this.size + 'px';
                
                this.x = Math.random() * (window.innerWidth - this.size);
                this.y = Math.random() * (window.innerHeight - this.size);
                
                this.vx = (Math.random() - 0.5) * 3;
                this.vy = (Math.random() - 0.5) * 1.5;
                if(Math.abs(this.vx) < 0.5) this.vx = 1;

                aquarium.appendChild(this.element);
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                if (this.x <= 0 || this.x + this.size >= window.innerWidth) this.vx *= -1;
                if (this.y <= 0 || this.y + this.size >= window.innerHeight) this.vy *= -1;
                
                let scaleX = this.vx > 0 ? -1 : 1;
                this.element.style.transform = `translate(${this.x}px, ${this.y}px) scaleX(${scaleX})`;
            }
        }

        function createFish(src, size) {
            fishes.push(new Fish(src, size));
        }

        function animate() {
            fishes.forEach(fish => fish.update());
            requestAnimationFrame(animate);
        }
        animate();

    </script>
</body>
</html>
